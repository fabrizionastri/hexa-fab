export interface GenericGateway<T extends { id: string }> {
  getById: (id: string) => Promise<T | undefined> // return undefined if ID not found or server error
  getAll: () => Promise<T[] | undefined> // return undefined if server error, return [] if no orders exist
  create: (entity: T) => Promise<T | undefined> // return undefined if server error, return entity with id if success. Entity can be posted with id (it will be retained) or without id (it will be generated by the store)
  deleteById: (id: string) => Promise<T | undefined> // return undefined if ID not found or if server error
  update: (id: string, partialEntity: Partial<T>) => Promise<T | undefined> // return undefined if ID not found or server error
  getByProperty: (property: keyof T, value: any) => Promise<T[] | undefined> // return undefined if server error
}

/* 
probably not a good idea have a sub-generic store. Better to have a single generic store
better to have a generic gateway and store, and then specific gateway and store for each entity that extends the generic one 
*/

// export interface GenericGatewayWithAccountId<T extends { id: string; accountId: string }>
//   extends GenericGateway<T> {
//   getByAccountId: (accountId: string) => Promise<T[] | undefined> // return undefined if server error
// }
